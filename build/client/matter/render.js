// Generated by CoffeeScript 1.9.3
var Bounds, Common, Composite, RenderPixi, Vector;

RenderPixi = Matter.RenderPixi;

Common = Matter.Common;

Composite = Matter.Composite;

Vector = Matter.Vector;

Bounds = Matter.Bounds;

RenderPixi.create = function(options) {
  var defaults, render, transparent;
  defaults = {
    controller: RenderPixi,
    element: null,
    canvas: null,
    options: {
      width: 800,
      height: 600,
      background: '#fafafa',
      wireframeBackground: '#222',
      hasBounds: false,
      enabled: true,
      wireframes: true,
      showSleeping: true,
      showDebug: false,
      showBroadphase: false,
      showBounds: false,
      showVelocity: false,
      showCollisions: false,
      showAxes: false,
      showPositions: false,
      showAngleIndicator: false,
      showIds: false,
      showShadows: false
    }
  };
  render = Common.extend(defaults, options);
  transparent = !render.options.wireframes && render.options.background === 'transparent';
  render.context = new PIXI.WebGLRenderer(render.options.width, render.options.height, {
    view: render.canvas,
    transparent: transparent,
    antialias: true,
    backgroundColor: options.background
  });
  render.canvas = render.context.view;
  render.container = new PIXI.Container();
  render.bounds = render.bounds || {
    min: {
      x: 0,
      y: 0
    },
    max: {
      x: render.options.width,
      y: render.options.height
    }
  };
  render.textures = {};
  render.sprites = {};
  render.primitives = {};
  render.spriteContainer = new PIXI.Container();
  render.textContainer = new PIXI.Container();
  render.container.addChild(render.spriteContainer);
  render.container.addChild(render.textContainer);
  if (Common.isElement(render.element)) {
    render.element.appendChild(render.canvas);
  } else {
    Common.log('No "render.element" passed, "render.canvas" was not inserted into document.', 'warn');
  }
  render.canvas.oncontextmenu = function() {
    return false;
  };
  render.canvas.onselectstart = function() {
    return false;
  };
  return render;
};

RenderPixi.clear = function(render) {
  var bgSprite, container, i, j, k, len, len1, ref, ref1, spriteContainer;
  container = render.container;
  spriteContainer = render.spriteContainer;
  ref = container.children;
  for (j = 0, len = ref.length; j < len; j++) {
    i = ref[j];
    container.removeChild(i);
  }
  ref1 = spriteContainer.children;
  for (k = 0, len1 = ref1.length; k < len1; k++) {
    i = ref1[k];
    spriteContainer.removeChild(i);
  }
  bgSprite = render.sprites['bg-0'];
  render.textures = {};
  render.sprites = {};
  render.primitives = {};
  render.sprites['bg-0'] = bgSprite;
  if (bgSprite) {
    container.addChildAt(bgSprite, 0);
  }
  render.container.addChild(render.spriteContainer);
  render.container.addChild(render.textContainer);
  render.currentBackground = null;
  container.scale.set(1, 1);
  return container.position.set(0, 0);
};

RenderPixi.world = function(engine) {
  var allConstraints, bodies, body, bodyA, bodyB, boundsHeight, boundsScaleX, boundsScaleY, boundsWidth, constraint, constraints, container, context, j, k, l, len, len1, len2, len3, len4, m, n, options, pointAWorld, pointBWorld, ref, render, text, world;
  render = engine.render;
  world = engine.world;
  context = render.context;
  container = render.container;
  options = render.options;
  bodies = Composite.allBodies(world);
  allConstraints = Composite.allConstraints(world);
  constraints = [];
  if (options.wireframes) {
    RenderPixi.setBackground(render, options.wireframeBackground);
  } else {
    RenderPixi.setBackground(render, options.background);
  }
  boundsWidth = render.bounds.max.x - render.bounds.min.x;
  boundsHeight = render.bounds.max.y - render.bounds.min.y;
  boundsScaleX = boundsWidth / render.options.width;
  boundsScaleY = boundsHeight / render.options.height;
  if (options.hasBounds) {
    for (j = 0, len = bodies.length; j < len; j++) {
      body = bodies[j];
      body.render.sprite.visible = Bounds.overlaps(body.bounds, render.bounds);
    }
    for (k = 0, len1 = allConstraints.length; k < len1; k++) {
      constraint = allConstraints[k];
      bodyA = constraint.bodyA;
      bodyB = constraint.bodyB;
      pointAWorld = constraint.pointA;
      pointBWorld = constraint.pointB;
      if (bodyA) {
        pointAWorld = Vector.add(bodyA.position, constraint.pointA);
      }
      if (bodyB) {
        pointBWorld = Vector.add(bodyB.position, constraint.pointB);
      }
      if (!pointAWorld || !pointBWorld) {
        continue;
      }
      if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld)) {
        constraints.push(constraint);
      }
    }
    container.scale.set(1 / boundsScaleX, 1 / boundsScaleY);
    container.position.set(-render.bounds.min.x * (1 / boundsScaleX), -render.bounds.min.y * (1 / boundsScaleY));
  } else {
    constraints = allConstraints;
  }
  for (l = 0, len2 = bodies.length; l < len2; l++) {
    body = bodies[l];
    RenderPixi.body(engine, body);
  }
  for (m = 0, len3 = constraints.length; m < len3; m++) {
    constraint = constraints[m];
    RenderPixi.constraint(engine, constraint);
  }
  ref = render.textContainer.children;
  for (n = 0, len4 = ref.length; n < len4; n++) {
    text = ref[n];
    render.textContainer.addChildAt(text, 0);
  }
  return context.render(container);
};

module.exports = RenderPixi;
